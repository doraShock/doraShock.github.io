<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java TCP+IP+Socket编程记录（上）]]></title>
    <url>%2F2017%2F11%2F09%2FJava-TCP-IP-Socket%2F</url>
    <content type="text"><![CDATA[命运坎坷，以后有空再写入文章中。由于新工作要求，需要了解java socket的开发，所以找了Java TCP/IP Socket编程原书第2版，Kenneth L.Calvert Michael J.Donahoo著，周恒民老师译，机械工程出版社出版的。本来想练习下不做笔记，但是有些知识还是记了好，不然忘记了都没地方找去，想看原文章的可以自行百度，或者自行找联系我的方法。本人是单纯的选择了几个点进行记录，理解起来应该还算简单，概念比较多，想了解的话得有耐心看。 基本概念和术语 计算机网络 由一组通过 通信信道 相互连接的机器组成，这些机器可分为 主机（hosts） 和 路由器（routers） 。 主机 就是指有应用程序运行的计算机， 应用程序 就是我们常用的软件，比如浏览器，聊天工具等，这些应用程序才是计算机网络的真正“用户”。 路由器 一般不运行程序，但是也有例外，它的作用是将信息从一个通信信道传递或转发到另一个通信信道。 通信信道（communication channel） 基于我们的目的可以解释为将字节序列从一个主机传输到另一个主机的一种手段，可以是有线电缆，如以太网，也可以是无线，比如WiFi，或者其它方式的连接。 在网络上相互传递信息的程序不直接与路由器进行交互，它们基本上感觉不到路由器的存在。 这些 信息（information） 是指由程序创建和解释的 字节序列。这些字节序列被称为 分组报文（packet） 。 分组报文 包含了完成目的的控制信息，也可以加入一些用户数据，定位分组报文目的地址的信息就是一个例子，路由器可以根据这些信息实现报文的转发。 协议（protocol） 相当于相互通信之间的程序达成的一种约定，定义了分组报文的交换方式以及包含的意义。 TCP/IP 协议族主要包含的协议有 IP协议（Internet Protocol，互联网协议） ， TCP协议（Transmission Control Protocol，传输控制协议） 和 UDP协议（User Datagram Protocol，用户数据报协议）。 如上图所示，网络层唯一存在的就是IP协议，它使两个主机之间的一系列通信信道和路由器看起来就像是单独一条主机到主机的信道。 IP协议提供了一种数据报服务：每组分组报文都由网络独立处理和分发。这样的话就要求每个IP报文必须包含一个保存目的地址的字段，就像邮件投递需要写地址和收件人，尽管邮件会保证送达包裹，但也有漏包，丢包等现象；IP协议也是这样，它使一个“尽力而为”（best-effort）的协议，偶尔会出现报文丢失，顺序混乱，重复发送的情况。 回到上图，传输层提供了TCP和UDP两种协议，它们都是建立在IP协议的基础之上，同时包含有寻址的功能。之前说的IP协议只是针对主机和主机之间的传输，传送到主机之后TCP和UDP使用 端口号（port number） 来区分主机中的应用程序，所以这两种协议也被称作 端到端传输协议（end-to-end transport protocol） ，因为它们是把信息从一个应用程序传到另一个应用程序，IP协议只是把信息从一个主机传到另一个主机。 TCP协议提供了一个 可信赖的字节流（reliable byte-stream）信道 可以用来检测和恢复IP协议提供的主机到主机信道中可能发生的报文丢失、重复等问题。TCP协议同样是一种 面向连接（connection-oriented） 的协议：在使用它进行通信之前，两个应用程序首先要建立一个TCP连接，这涉及了相互通信的两台机器的TCP部件间完成的 握手消息（handshake message） ；TCP连接和文件的 输入输出（Input/Output，I/O） 类似，一个应用程序的文件写入然后由另一个应用程序去读取就是一个简单的TCP连接的适当模型。 UDP协议只是对IP协议进行了扩展，使之可以支持端对端的传输，并没有对可能存在的报文丢失等问题进行处理，使用UDP协议的时候要自行处理相关问题。 关于互联网地址，由二进制数字组成，分为 IPv4 和 IPv6 ，最开始用的是IPv4，后来由于浪费严重，于是产生了IPv6的地址。这两种地址分别对应了两个版本的标准互联网协议。 IPv4地址长32位，被表示为一组4个十进制数，表示方法叫 点分形式（） ，即每两个数字之间用圆点隔开，每个数字的范围是0~255，示例：10.23.0.1。每个版本的IP协议都定义了一些特殊用途的地址，注意之一是 回环地址（loopback address） ，该地址被分配到一个 回环接口（loopback interface） ，并且每个主机上都有，即该主机不能连接网络，没有其它接口的时候回环接口也可以使用，功能是把接收的报文直接返回给发送者，一般用来测试，IPv4的回环地址是 127.0.0.1，从技术上讲，127开头的都是回环地址;另外一个特殊用途的地址是那些“私有用途”的地址，一般用于局域网当中，IPv4中所有以10或192.168开头的地址，以及第一个数是172，第二个数在16~31间的地址都是；还有一个 本地链接 （link-local） 或叫做“自动配置”地址在IPv4中以169.254开头，这类地址只能用于同一网络的主机之间通信，路由器不会转发；最后一个叫做 多播（multicast） ，普通IP地址即单播地址，只与唯一一个目的地址管理，多播地址可能关联任意数量的目的地址，在IPv4中表示为第一个数字在224~239之间。 IPv6地址长128位，16个字节由几组16进制的数字表示，数字之间由分号隔开，示例：2000::fdb8:0:0:1:ab:853c:39a1,每组数字代表地址中的两个字节，并且0开头可以省略。回环地址是0:0:0:0:0:0:0:1，没有私有地址，本地链接地址是前十六位由FE8开头的地址，多播地址由FF开头。 找到了地址，就得找收件人，或者门牌号把消息发送过去给里面的应用程序，这个标志在网络里被叫做端口号，端口号的范围是1~65535,0被保留。互联网的端口号授权机构维护了一个包含所有已经约定使用的端口号列表：http://www.iana.org/assignments/port-numbers。 关于域名，是一般用户常见并且容易记住的，实际上通信协议只能识别二进制的地址，使用域名的时候系统会把它解析成二进制地址，这和TCP/IP提供的基本服务没有关联，好处是容易记忆，并且提供间接层：IP变化的时候用户不可见。 域名解析服务可以从各种各样的信息源获取信息。两个主要的信息源是 域名系统（Domain Name System，DNS） 和本地配置数据库。 客户端（client） 和 服务端（server） 代表了两种角色。客户端是通信的发起者，服务端是被动等待通信的接收方，并作出相应，这样就组成了 应用程序（application） 。建立连接的时候客户端需要知道服务端的地址和端口号，这样也就区分了哪个是客户端哪个是服务端，连接建立之后二者就没有差别了。 socket是一个抽象层，应用程序通过它来发送和接收数据。TCP协议使用 流套接字（stream socket） ，UDP协议使用 数据报套接字（datagram socket） ，流套接字提供了一个可信赖的字节服务，数据报套接字提供了一个best-effort服务，应用程序可通过它发送最长65500字节的个人信息。一个TCP/IP套接字由一个互联网地址，一个端对端协议以及一个端口号唯一确定，并且主机中的多个程序可以同时访问同一个套接字，关系图如下： 套接字地址 本节用一个程序说明Java关于网络地址方面的类和方法，以便理解Java对地址的处理方法，更具体方法可自行查看api。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.net.*;import java.util.Enumeration;/** * InetAddress类获取网络地址 * @author shock */public class TestInetAddress &#123; public static void main(String[] args)&#123; try &#123; // 获取主机的每个接口所对应的networkInterface实例的枚举 Enumeration&lt;NetworkInterface&gt; interfaceEnum = NetworkInterface.getNetworkInterfaces(); if(interfaceEnum == null) System.out.println("--------未发现网络接口--------"); // 即便主机没有网络连接，回环接口会有，除非该主机没有网络子系统 else &#123; while(interfaceEnum.hasMoreElements())&#123; // 循环打印每个接口 NetworkInterface networkInterface = interfaceEnum.nextElement(); // 获取接口本地名称，一般由字母和数字联合组成 System.out.println("interface " + networkInterface.getName() + "："); // 获取与该接口关联的每个地址实例InetAddress的枚举 Enumeration&lt;InetAddress&gt; inetAddressEnum = networkInterface.getInetAddresses(); if(!inetAddressEnum.hasMoreElements()) System.out.println("\t该接口下无网络地址！"); else &#123; while (inetAddressEnum.hasMoreElements())&#123; // 循环打印接口下地址 InetAddress inetAddress = inetAddressEnum.nextElement(); System.out.println("\tAddressName：" + inetAddress.getHostName()); System.out.print("\tAddress" + (inetAddress instanceof Inet4Address ? " v4" : (inetAddress instanceof Inet6Address ? " v6" : " ?") ) ); System.out.println("：" + inetAddress.getHostAddress()); &#125; &#125; &#125; &#125; &#125; catch (SocketException e) &#123; // getNetworkInterfaces方法会抛异常 System.out.println("获取NetworkInterface失败：" + e.getMessage()); &#125; &#125;&#125; 输出结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface lo： AddressName：127.0.0.1 Address v4：127.0.0.1 AddressName：0:0:0:0:0:0:0:1 Address v6：0:0:0:0:0:0:0:1interface eth0： AddressName：DESKTOP-BF8HBLI Address v4：192.168.1.230 AddressName：DESKTOP-BF8HBLI Address v6：fe80:0:0:0:e5ce:f1c6:723b:e563%eth0interface eth1： 该接口下无网络地址！interface net0： 该接口下无网络地址！interface net1： 该接口下无网络地址！interface net2： AddressName：DESKTOP-BF8HBLI Address v6：2001:0:9d38:6ab8:1007:3398:3f57:fe19 AddressName：DESKTOP-BF8HBLI Address v6：fe80:0:0:0:1007:3398:3f57:fe19%net2interface eth2： 该接口下无网络地址！interface net3： 该接口下无网络地址！interface net4： 该接口下无网络地址！interface eth3： 该接口下无网络地址！interface ppp0： 该接口下无网络地址！interface eth4： 该接口下无网络地址！interface eth5： 该接口下无网络地址！interface eth6： 该接口下无网络地址！interface eth7： 该接口下无网络地址！interface eth8： 该接口下无网络地址！interface eth9： 该接口下无网络地址！interface eth10： 该接口下无网络地址！interface eth11： 该接口下无网络地址！interface eth12： 该接口下无网络地址！interface eth13： 该接口下无网络地址！ TCP套接字 Java中为TCP协议提供了两个类：Socket和ServerSocket。一个TCP连接是一条抽象的双向信道，两端分别由IP地址和端口号确定。开始通信时要建立一个TCP连接，需要先由客户端TCP向服务端TCP发送请求。ServerSocket监听TCP连接请求并为每个请求创建一个Socket实例。这样的意思就是服务端要同时处理ServerSocket实例和Socket实例，而客户端只需要处理Socket实例，具体例子见如下代码，服务端回馈服务器，即把接收到的消息原样返回给客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import org.testng.annotations.Test;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketAddress;import java.net.SocketException;/** * tcp/ip socket练习 * @author shock */public class TestTcpIpSocket&#123; /** * 测试tcp socket的echo服务端 * 返回接收的参数 */ @Test public void TCPEchoServer() throws IOException &#123; int serverPort=7777; // 监听特定端口上的客户端socket连接请求 ServerSocket serverSocket = new ServerSocket(serverPort); while(true)&#123; // 永久循环，迭代处理新连接 /** 为新连接的tcp请求提供一个新的已连接的socket实例 * 当没有新连接时候，accept方法阻塞等待 * 多个指定此端口的请求连接的时候，未处理的连接会排在一个队列里等待 */ 返回的套接字实例已经连接到客户端，并且准备好读写数据 Socket clinetSocket = serverSocket.accept(); // 该方法返回包含客户端地址和端口号的实例 SocketAddress clientAddress = clinetSocket.getRemoteSocketAddress(); // 打印客户端地址实例，示例：/127.0.0.1:56262 System.out.println("连接客户端地址：" + clientAddress); InputStream in = clinetSocket.getInputStream(); OutputStream out = clinetSocket.getOutputStream(); int recMsgSize; // 新建接收字节数组 byte[] recBuf = new byte[32]; // 读取接收数据并放入新建数组中，获取接收内容大小 while((recMsgSize=in.read(recBuf))!=-1)&#123; // 打印接收数据 System.out.println("接收消息：" + new String(recBuf)); /** 发送接收的数据,第一个参数是所要发送数据 * 第二个参数是发送数组的起始位置，及偏移量 */ 第三个参数是发送数组的长度 out.write(recBuf,0,recMsgSize); &#125; clinetSocket.close(); // 关闭客户端套接字的实例 &#125; &#125; /** * 测试tcp socket的echo的客户端 * 发送消息并接收打印 */ @Test public void TCPEchoClinet() throws IOException &#123; // 端口号有效范围是0~65535，如果设0将选择任意未使用端口 // 底层TCP协议只能处理IP地址，若是给出域名，socket具体实现时会解析成相应地址 Socket socket = new Socket("127.0.0.1",7777); System.out.println("------连接Echo服务器成功，开始发送消息------"); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); byte[] data = "测试".getBytes(); out.write(data); // 将消息从建立好的连接传送到指定服务器 int recByteTotal = 0; int recByte; // 循环读取，及不止用一个read方法是因为返回信息可能被分成多个部分， // 所以一个write发送的信息不能只用一个read来读取 while(recByteTotal&lt;data.length)&#123; /** read方法接收消息，第一个参数是消息存放的数组 * 第二个参数是第一个字节放入的位置，第三个参数是放入数组最大字节数 * 读取的字节是从数组尾部开始插入 */ 新加入字节放入第二个参数标记的位置，新字节往右移，移动到该位置的老字节被摒弃 if((recByte=in.read(data,recByteTotal,data.length-recByteTotal))==-1) throw new SocketException("连接断开"); recByteTotal += recByte; &#125; // 打印返回的消息 System.out.println("返回消息：" + new String(data)); socket.close(); // 关闭套接字 &#125;&#125; Socket实例的创建，首先需要知道服务端的地址和端口号进行连接，然后返回给客户端，可以指定本地地址和端口号，没有指定则使用默认地址和可用端口号，在有多个接口的主机上指定本地地址是有效的；如果没有指定目标地址和端口号则需要使用connect()方法进行显式连接。 ServerSocket实例的创建则需要指定当前应用程序的端口号，如果没有设置端口号则需要bind()方法进行绑定，端口号有效范围是0~65535，端口号设0则选择任意未被使用的端口号，accept()方法把连接成功的Socket实例返回给服务端。 TCP套接字的基本输入输出形式是流（stream）抽象，Java1.4加入NIO（New I/O）工具提供另一种替代的抽象形式下面会说。流只是一个简单的字节序列，Java输入流支持读取文件，输出流支持写出文件。TCP服务端和客户端种每个Socket实例都有维护一个InputStream和OutputStream实例，我没把数据从一端的输出流写入后最终将能从连接的另一端的输入流种读取。 OutputStream是Java种所有输出流的抽象父类，通过它我们可以向输出流写字节，刷新缓存区和关闭输出流；InputStream是所有输入流测抽象父类，使用它可以从输入流读取字节和关闭输入流。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>note</tag>
        <tag>Socket</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础教程学习记录一——运算符]]></title>
    <url>%2F2017%2F09%2F19%2FJava-basics-tutorial-learning-notes%2F</url>
    <content type="text"><![CDATA[由于前期学习不主动规范，面试时候也没有去翻看面试题，导致暴露自己基础薄弱的问题，就找了本基础书进行翻看，寻找自己遗漏的知识点并进行记录，从而为自己以后看jvm，设计模式，性能优化，高并发和算法等之类的内容打个好的基础。这边提前说下，我记录的都是我自己的遗漏的知识或者之前就算遇到但是没用过的知识点，记录下来改进自己的编码习惯，完善自己的知识，读者选读就好了，也不是说这些都是重点。 位运算符 二进制补码：Java中用补码的方式来表示负数，也就是把一个正数转化成二级制然后按位取反（0变成1,1变成0），然后把结果加1。比如42的二级制是00101010，按位取反是11010101，加1后得到11010110，表示的就是-42。如果解码负数一样是把二进制按位取反后加1，-42的二级制表示11010110按位取反是00101001,转换成十进制就是41，然后加1就得到42。考虑到零的交叉（zero crossing）问题，们规定，-0和0的表示方法一样。 按位非（NOT） 按位非也叫做补，一元运算符NOT“~”是对其运算数的每一位取反。 例如，数字42，它的二进制代码为：00101010 经过按位非运算成为：11010101，转化成十进制就是-41。 按位与（AND） 按位与运算符“&amp;”，把两个数转化成二级制按位计算，如果两个运算数都是1，则结果为1，其他情况下，结果均为0。看下面的例子： 1234 0 0 1 0 1 0 1 0 42 &amp; 0 0 0 0 1 1 1 1 15--------------------------- 0 0 0 0 1 0 1 0 10 即用Java计算42&amp;15的结果就是10。 按位或（OR） 按位或运算符“|”，把两个数转化成二级制按位计算，有一个运算数是1，则结果为1。如下面的例子所示： 1234 0 0 1 0 1 0 1 0 42 | 0 0 0 0 1 1 1 1 15 -------------------------- 0 0 1 0 1 1 1 1 47 即用Java计算42|15的结果就是47。 按位异或（XOR） 按位异或运算符“^”，只有在两个比较的位不同时其结果是 1,否则结果是0，示例如下 1234 0 0 1 0 1 0 1 0 42 ^ 0 0 0 0 1 1 1 1 15 -------------------------- 0 0 1 0 0 1 0 1 37 即用Java计算42^15的结果就是37。这里测试异或的作用根据它的原理：0异或任何数结果为异或的那个数， 自己异或自己是0，并且异或满足交换律，所以可以处理一些算法，比如说有组数据丢失了一个数，想要找出丢失的那个数就可以把原数据和已丢失数的数据合并进行逐个异或，最后的结果就是丢失的那个数，因为相同的数都是偶数的个数，只有丢失那个是奇数个数。 左移运算符 左移运算符“&lt;&lt;”使指定值的所有位都左移规定的次数，每左移1位，高阶位丢弃，右面补0。在Java里面byte和short类型的值进行左移会自动扩展为int类型，每移动1位第31位就会被丢弃，同理，long类型的值每移动1位第63位就会被丢弃。 1234 0 0 0 0 1 1 1 1 15 &lt;&lt; 2------------------------- 0 0 1 1 1 1 0 0 60 进行简单的运算后就会发现规律：把 m 左移 n 位相当于进行运算 m * 2ⁿ，用该运算符进行乘2运算会非常的快速，但是要注意所使用类型的范围。 右移运算符 右移运算符“&gt;&gt;”使指定值的所有位都右移规定的次数，每右移1位，低阶位丢弃，新增的最高位（最左边的位）由原来最高位的数字补充，例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension）。 1234 0 0 1 0 0 0 1 1 35 1 1 1 1 1 0 0 0 –8 &gt;&gt; 2 &gt;&gt; 1------------------------------------------------------ 0 0 0 0 1 0 0 0 8 1 1 1 1 1 1 0 0 –4 右移的规律是：把值每右移一次，就相当于将该值除以2并且舍弃了余数，这样就可以快速把一个整数进行除2运算，同时一样要注意该整数大小。 无符号右移 无符号右移运算符“&gt;&gt;&gt;”使指定值的所有位都右移规定的次数，每右移1位，低阶位丢弃，左边补0。右移运算符保留原值符号有些时候不是别人想要的，常用与处理像素或图形时。 1234 11111111 11111111 11111111 11111111 int型- 1的二进制代码 &gt;&gt;&gt; 24 无符号右移24位------------------------------------------------------------- 00000000 00000000 00000000 11111111 int型255的二进制代码 短路（short-circuit）逻辑运算符 在之前没有系统的梳理过程中一直认为的是按位与和逻辑与，按位或和逻辑或，看了以后了解到“|”在位运算符中叫按位或，主要用于数值的计算，在逻辑运算符中叫逻辑或，用于判断，而“||”是Java中特殊的逻辑运算符短路或，“&amp;”运算符和“&amp;&amp;”也是同理。在逻辑运算符中，逻辑与和逻辑或是无论结果如何运算符两边的程序都会执行，而且根据运算来看的话，在逻辑或运算中如果左边为真则结果一定为真，在逻辑与运算中如果左边为假则结果一定为假，在这个时候Java就推出短路与和短路或，如果有类似的情况的话那么右边的程序就不会运行，起到保护作用，示例如下： 123if (denom != 0 &amp;&amp; num / denom &gt; 10)&#123; ……&#125; 上述程序如果demo为0则结果为假后面不执行，如果demo不为0就可以作为除数，这样就避免了程序运行中出现被0除的错误。 ？运算符 Java提供了一个特别的三元运算符“？”，一般可以用来取代if-else语句，用法和C/C++里面的差不多，“？”左边写布尔类型的值，如果为真执行“？”后面“:”前面的内容，如果为假执行“:”后面的内容。示例如下： 1ratio = denom == 0 ? 0 : num / denom; 如果demo是0的话则ratio结果为0，否则结果是num/demo。给一个使用“？”运算符计算绝对值的代码示例： 1234567891011121314151617// Demonstrate ?.class Ternary &#123; public static void main(String args[]) &#123; int i, k; i = 10; k = i &lt; 0 ? -i : i; // 获取 i 的绝对值 System.out.println(i + " 的绝对值是 " + k); i = -10; k = i &lt; 0 ? -i : i; // 获取 i 的绝对值 System.out.println(i + " 的绝对值是 " + k); &#125;&#125;代码输出结果如下： 10 的绝对值是 10 -10 的绝对值是 10 运算符优先级 和数学的符号一样，Java中的运算符是有一个先后顺序的，下表排列了Java中各运算符从最高到最低的优先级。 123456() [] . ++ --~ ! * / %+ - &gt;&gt; &gt;&gt;&gt; &lt;&lt;&gt; &gt;= &lt; &lt;= ==!= &amp; ^ || &amp;&amp; | ? : = op=]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>note</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstarp 3 Typeahead —— Bootstarp输入框自动补全插件]]></title>
    <url>%2F2017%2F09%2F12%2FBootstarp-3-Typeahead%2F</url>
    <content type="text"><![CDATA[在本次开发过程中遇到输入框模糊搜索的功能，用的Bootstrap就去查看官方api，但是最新的api没有该插件，然后搜索到了叫Typeahead，查看bootstrap2的api里面有对应的一个说明，根据api和别人的例子进行实现，功能是实现了，但是实现效果比较不理想，想了解的话可以自己去查看api，因为只能对name数组进行模糊搜索，但是一般我们的相关数据肯定是要获取id的，以json的形式就没办法很好的展现了。 正文 Typeahead插件开放了几个方法，进行重写覆盖之后就可以实现对应功能了，链接在底部，我看着思路是对的，但是按照对应方法去实现的时候总是补全不了，不知道是我什么地方搞错了，比较崩溃，前后搞了很久，后来还是没有实现，再找其它思路的时候找到了原来api并没有进行更新，或许是别人进行了修改吧，我也不知道是不是bootstrap官方的GitHub，但是下载最新的Typeahead改写了原有的process方法，传json的话对应id和name字段就可以直接解析了，示例如下： 12345678910111213141516171819202122 $("#id").typeahead(&#123; source: function (query, process) &#123; var json=[]; $.ajax(&#123; url: "", type: "post", data: &#123; userType: $("#pay_user_type").val(), query:query &#125;, dataType: "json", async: false , success: function (data) &#123; json = data.records; &#125; &#125;); return process(json); &#125;, updater: function (obj) &#123; return obj.name; &#125;&#125;); 直接source定义数据源就可以了，如果是ajax的话实现范围就广泛很多了，有两个参数，query是输入内容，传输的话可以优化搜索，不传也没事，返回前端的数据该插件有匹配函数，process则是解析函数，解析成差劲可以识别的数据源，updater方法是点击事件，返回值是显示在输入框中的数据，我这边是在里面把点击数据的id保存到页面的隐藏输入框中操作在里面，所以重写了一下，如果有匹配内容修改的话也可以在这里返回。其它方法我就不介绍了底部附上链接，需要的可以自己查看，这两个方法已经满足我的需求实现了。 链接 【Bootstrap】 typeahead自动补全：http://www.cnblogs.com/shiyu404/p/6344591.html Bootstrap 3 Typeahead：https://github.com/bassjobsen/Bootstrap-3-Typeahead]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>UI</tag>
        <tag>plugin</tag>
        <tag>Bootstarp</tag>
        <tag>Typeahead</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2017%2F08%2F16%2FLinux-and-Nginx-command%2F</url>
    <content type="text"><![CDATA[在使用Linux的过程中会用各种各样的命令，有时候记不住了再去百度也很麻烦，记录一下自己常用的命令，找起来也方便，后期也会随时更新。 Linux相关 12345678910111213141516171819ls -a #查看目录下所以文件pwd #查看当前路径mkdir test #新建文件夹mv #移动或重命名cp -r test test1 #复制文件 -r递归目录下所有文件touch test/a.txt #创建txtrm -rf test/ #删除文件find #在文件系统中搜索某文件locate interfaces #搜索interfaces文件vi test #文本编辑器ESC或i或： #切换编辑模式：命令模式、插入模式、编辑模式命令模式下：:q #退出:q! #强制退出:wq #保存并退出:set number #显示行号:set nonumber #隐藏行号/apache #在文档中查找apache 按n跳到下一个，shift+n上一个yyp #复制光标所在行，并粘贴 Tomcat相关 123456netstat –apn #查看端口占用./startup.sh #启动tomcat./shutdown.sh #停止tomcattail -f ../logs/catalina.out #查看tomcat的控制台输出ps -ef |grep tomcat #看是否已经有tomcat在运行了kill -9 pid #如果有，用kill;pid 为相应的进程号 Nginx相关 1234./nginx -s reload #修改配置后重新加载生效./nginx -s reopen #重新打开日志文件./nginx -t #查看nginx配置文件路径以及该文件语法是否正确ps -ef | grep nginx #查看启动的Nginx目录 maven相关 1234这些是在window上的命令，有些包网上没有，或者下载不下来的时候，有时候用baseurl打包不了，可以导入本地maven库，坏处是别人本地也要导入，不然引用不到$&#123;basedir&#125; #在pom中jar路径前加，表示项目根目录,即包含pom.xml文件的目录，同$&#123;project.basedir&#125;手动添加jar包到本地仓库：mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar 2017年8月23日 今天在部署项目的时候，项目里的tcp连接连接不上，查找之后发现是防火墙没有开放端口，记录linux防火墙相关命令： 123456789101112131415161718192021222324252627282930telnet ip port #检测远程端口是否通畅（Windows适用）service iptables stop #关闭防火墙service iptables start #启动防火墙service iptables restart #重启防火墙service iptables status #查看防火墙状态 -A #在指定链的末尾添加（append）一条新的规则 -D #删除（delete）指定链中的某一条规则，可以按规则序号和内容删除 -I #在指定链中插入（insert）一条新的规则，默认在第一行添加 -R #修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换 -L #列出（list）指定链中所有的规则进行查看 -E #重命名用户定义的链，不改变链本身 -F #清空（flush） -N #新建（new-chain）一条用户自己定义的规则链 -X #删除指定表中用户自定义的规则链（delete-chain） -P #设置指定链的默认策略（policy） -Z #将所有表的所有链的字节和数据包计数器清零 -n #使用数字形式（numeric）显示输出结果 -v #查看规则表详细信息（verbose）的信息 -V #查看版本(version) -h #获取帮助（help） 针对固定ip开放端口，编辑/etc/sysconfig/iptables，添加-A INPUT -m state --state NEW -m tcp -p tcp -s 127.0.0.1 --dport 6379 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp -s 126.212.173.185 --dport 6379 -j ACCEPT 查看iptables状态是提示 iptables：unrecognized service，则需要安装（保证联网状态）。 apt-get install iptables //Debian,Ubuntu使用此命令yum install iptables //Linux,CentOS使用此命令]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tomcat</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tampermonkey安装说明-百度云非破解不限速下载方法]]></title>
    <url>%2F2017%2F08%2F15%2FInstructions-for-Tampermonkey%2F</url>
    <content type="text"><![CDATA[本来是看了别人的东西，找到了这个让我惊喜的方法。百度云大家都会用到，但是限制大文件直接下载和软件非会员限速就让我们很头疼了，不想花钱但是云盘的作用真的很方便，不仅仅是一些项目和技术文档，还有各种福利。一开始不打算自己记录，但是找的内容比较散，而且换个地方就找不到了，所以最终我还是写到自己的博客里，尽量写的充实一点，完整点，当然我也刚用，我只能把使用方法写的详细，就像标题说的，我用的最好用的就是百度云解析下载地址，还有其他的方法也很简单好用，下面会介绍怎么查看。 插件安装 Tampermonkey支持多个浏览器，主流浏览器都可以使用，底层我也没去了解，做web编程的应该大致了解就是加了一些JavaScript语言，精通的人也可以自己研究编写脚本。 之前百度网盘分享的文件是可以不论大小使用下载器直接下载的，首先要准备两个百度账号，使用一个关注另外一个，找到要下载的文件保存到自己的网盘，然后分享，登陆另外一个账号到分享动态直接点击下载没有大文件显示，并且可以用下载器如下图 所以说如果是这样的话有前端开发经验的人看看代码就可以直接下载自己想要的东西了，一个是我太懒，第二个切换账号也不方便，然后就找到了本篇的方法。 软件安装很简单，本教程以360安全浏览器为例，下面是各个浏览器下载地址： 123456789常用浏览器安装： 搜狗浏览器： http://ie.sogou.com/app/search/Tampermonkey 360安全浏览器： https://ext.se.360.cn/webstore/search/tampermonkey 360极速浏览器： https://ext.chrome.360.cn/webstore/search/tampermonkey 火狐浏览器： https://addons.mozilla.org/zh-CN/firefox/addon/tampermonkey/?src=search 遨游浏览器： http://extension.maxthon.cn/detail/index.php?view_id=1680&amp;category_id= 欧朋浏览器： https://addons.opera.com/zh-cn/extensions/details/tampermonkey-beta/?display=en （遨游浏览器的是Violentmonkey）其它浏览器可以去浏览器的拓展中心搜索 Tampermonkey 然后进行安装 如果嫌弃地址不好记，也和其它浏览器一样去拓展中心搜索，以360安全浏览器为例，打开浏览器，右上菜单栏有个扩展，点击后选择添加，如果没找到可以鼠标右键浏览器头部，勾选插件栏 然后在右上角搜索栏搜索Tampermonkey，然后选择安装就可以了 脚本安装 安装完成后在右上角插件栏就会多一个插件，点击选择获取新脚本，点击图片中所示的GreasyFork就可以进入脚本仓库，这里面有各种别人写好的脚本上传，都很有用，可以搜索自己想要的脚本 比方说我们搜索百度的话，就可以看到跟百度有关的脚本了，如下所示 当然这里面就有网盘的脚本了，但是我也不知道是不是有效的，我下载直接下载助手没有用，不知道是因为冲突还是什么原因原因，下面贴上几个有用的脚本链接，我自己用没问题的： 1234567百度网盘解析下载地址：https://greasyfork.org/zh-CN/scripts/29796-百度云解析-blog-tsyinpin-com-优化版解决百度云大文件下载限制：https://greasyfork.org/zh-CN/scripts/17800优化百度-搜狗-谷歌搜索结果之重定向去除-去广告：https://greasyfork.org/zh-CN/scripts/14178知乎免登陆：https://greasyfork.org/zh-CN/scripts/6489vip视频在线解析：https://greasyfork.org/zh-CN/scripts/27349网页强制复制：https://greasyfork.org/zh-CN/scripts/218网盘提取工具：https://greasyfork.org/zh-CN/scripts/18733 我使用的就是网盘提取工具和下载地址解析，可以不用输提取码，直接解析地址添加到下载器中下载，安装方法如下，打开网盘解析的下载地址，点击安装此脚本 跳转后选择安装，然后页面自动关闭，这样就安装完成了 安装完我习惯重启浏览器，点击插件栏的Tampermonkey，选择仪表盘就可以管理自己的插件了 这个时候打开百度网盘，选择需要下载的文件，你会惊喜的发现多了个按钮 点击复制链接就会跳出来下载的地址了，复制后可以在迅雷里面新建任务，我用的是猎鹰下载器，不用登陆，而且简约，重要的是软件很小，缺点是无法下载torrent文件，而且如果网盘勾选文件夹的话会自动下载压缩文件 最后一张图就可以看到，很快的下载速度，猎鹰自己搜索下载就可以了，我是在360软件管家里直接下载的，我觉得软件管家现在挺好的，一些冷门软件以及开发软件都有收录。 结尾 当然你们有更好的方式可以不用参照，比方说破解版，我是不想下载一个软件占地方，而且觉得破解版有时没有下载器下载快，还有就是之前破解版有的过一段时间就没法用了，所以就没搞，如果想要破解版可以自己寻找，我下面放的外链里面也有的，你们自己看下吧。 友情链接 精品软件推荐—百度云另外一种破解限速的方式&lt;提取资源下载地址&gt; [油猴Tampermonkey] 脚本安装教程+自用脚本推荐 [教程、无技术含量] 简单的油猴脚本编写教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Tampermonkey</tag>
        <tag>百度云</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题yilia配置和畅言评论配置]]></title>
    <url>%2F2017%2F08%2F11%2Fhexo-theme-litten%2F</url>
    <content type="text"><![CDATA[上一篇博客讲了hexo的安装以及提交到GitHub访问，本来想早点写这个主题配置的博客，但是新人写博客真的很耗时间，上篇博客就写了好久，加上工作等原因，也就一直没有写，今天觉得还是写出来吧，了了我一桩心事，而且既然做博客的话就做的认真一点。 hexo的主题还是非常的丰富的，可以直接百度，我在知乎上看到回答的有哪些好看的Hexo主题，点击进去看别人推荐就好了，而且有的直接贴图，并且带了链接，没有的话也可以直接百度喜欢的主题进行查看，有基础的话也可以自己写主题哦。我用的主题是yilia，今天主要讲的就是这个主题的配置。 Hexo配置 每个人喜欢的东西不一样，这个主题也有很多人在用，我比较喜欢简约，没有太多的栏目，并且带点小特效，于是就选择了这个主题。 首先访问yilia主题的主页，作者是放在GitHub上面的：https://github.com/litten/hexo-theme-yilia。下载下来以后就可以放到hexo文件夹下面的themes主题文件夹下面，然后在hexo的配置文件_config.yml中修改theme为yilia，然后整个配置文件我会贴在下面，并且加上注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Shock.Le #网站标题subtitle: 一将功成万骨枯 #网站副标题description: 小小程序员~ #网站描述author: DoraShock #您的名字language: zh-CN #网站使用的语言 timezone: #网站时区。Hexo 默认使用您电脑的时区# URL网址## If your site is put in a subdirectory, ## set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;## 如果您的网站存放在子目录中，例如 &apos;http://yoursite.com/blog&apos;，## 则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /child/。url: https://dorashock.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/codei18n_dir: lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:doraShock/doraShock.github.io,master coding: git@git.coding.net:DoraShock/dorashock.git,masterfeed: type: atom path: atom.xml limit: 100# 配置yilia主题所有文章点击自动生成目录jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 这是我的配置，如果有其它需求，在对应位置按照标准修改就可以看，就是别忘了“:”后面一定要有一个空格。上面的root节点配置就是我在上一篇提到的你域名带子路径的情况下的主题不展示处理方案，写在这里就可以啦，当然这个配置文件依旧是借鉴了嘟嘟大神，想了解更多hexo的可以在上篇博客中找到链接去查看，我只写这两篇了。 yilia配置 hexo配置好了，主题也放进去了之后，就可以 hexo g 然后 hexo s 在本地预览效果了，如果满意的话就可以直接部署到GitHub或者coding了，手机访问的话也适配哦。当然也有很多可以配置的内容，yilia主题的作者在主页上也有介绍，下面贴上我的配置，配置文件是主题文件yilia文件夹下的_config.yml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124# Header# 菜单，显示在页面左侧竖直排列，后面的路径可以筛序文章，只要在文章头部标签或类别里有就可以了我筛选的是类别，可以改成tagmenu: 主页: / 文章: /categories/文章 技术: /categories/技术# 左下角的链接，看个人喜好subnav: github: &quot;https://github.com/doraShock&quot; weibo: &quot;http://weibo.com/3316441595/&quot; rss: /atom.xml #zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; mail: &quot;mailto:872149493@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &apos;谢谢老板的打赏~&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 2# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos;# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar: /assets/blogImg/head.png#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: changyan_conf: #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#a0cfe4&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#a0cfe4)&apos;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: false aboutme: &apos;关于我&apos;friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 向前进&lt;br&gt;&lt;br&gt;每天积累一点点&lt;br&gt;&lt;br&gt;享受生活 这边也还是注意“：”后面要留空格，我本来修改博客的头像的，弄了半天一直编译报错，找了好久，最后突然想到这个，改了就可以了，rss的生成方式可以百度，很简单我就不说了，头像图片放在hexo的source文件夹里面，可以建路径，编译后该文件夹下面的都是一级目录，很多东西都可以放在里面，编译后public文件夹下面就会有相同的文件了，还有博客浏览器标签页的图标的话在source文件夹下面把自己的图片命名为favicon.png就可以了。 现在的任何东西都是可配置为主，无论是框架还是hexo主题，植入评论的话作者弄成可配置直接添加就可以了，具体内容下一段讲。 如果在配置过程中遇到问题的话，可以自行修改源码，如果不知道原因，想讨论或者询问的话在yilia主页Issues里面可以查询或者提问问题如下所示，这边我的回到顶部效果并没有，也不知道是什么问题。 畅言配置 其它的主题没有研究过，选择yilia主题的博主就比较方便，只要有 appid 和 app key 就可以了，如果想自己弄的话也可以修改主题源码，找到位置按照畅言的提示添加代码进去就可以了；评论系统也有很多，我本来也想弄网易云跟帖的，因为是网易云音乐里面一样的评论风格，但是有个通知停止服务了，多说也有很多人用，但是也有消息称无法评论了，好吧，畅言效果也不错的。 首先登录畅言官网注册账号，很简单，有账号的就不用注册了，然后进入后台系统。 图片下面的畅言秘钥里有 APP ID 和 APP KEY 两个东西，分别填入yilia主题畅言配置里的 changyan-appid 和 changyan-conf节点里面，这个时候就可以把自己博客上传了，因为后面配置好了本地不需要修改就可以使用畅言评论了。 打开系统设置-通用设置，填写信息如下图。 站点名称可以随便写，站点网址和备案号要写对应的，域名白名单里写上你所使用的博客地址就可以了，备案号是必须要有的，没有的话这里可以填写别人的域名和备案号，审核通过以后在再成自己的，也可以不改，只要白名单里面有你的博客的地址就可以了。没有备案号的话好像可以使用七天，审核过程中，再登录自己的博客，打开一篇文章拉倒最底部，就可以看到畅言的评论系统了。 这里畅言的评论框下面的标签是点不开的，原因是因为点击所有文章的弹出侧边栏的内容把该部分遮住了的原因，弹出后在弹回去就可以使用表情了。 但是这样肯定不可以，还是要解决问题的，我在 Issues 里面搜索有的人是把这地方的左边距加大，但是我觉得效果不完美，我自己查看元素发现点开前和点开后弹出栏多了一个 class:hide ，我再源代码上加上去以后，编译后在访问还是没有该 class ，清除记录后也一样，后来我再去看，发现 hide 的样式只是 z-index 变为0了，于是我把默认的 z-index:998 修改成 z-index:1 ,在上传以后就没有问题了，测了测基本功能，没什么影响，于是就这样使用了，具体修改 Hexo\themes\yilia\source 路径下的 main.266c1c.css，找到 .tools-col 样式，有好几个，只有一个有 z-index 属性，修改了就可以了。 其它 对了，最后再说一下，想要自己的博客或者文章可以在百度搜索里面搜索到的话，具体参考上一篇博客中的嘟嘟大神的博客里找如何认证网站。当然按照百度认证的文件认证来说，我是一次都没成功，网上找的删除所有内容也不行，后来试了下加标签的就可以，但是也是在我删了《!DOCTYPE HTML》标签然后把百度给的标签放在 《html》 标签下的第一行才可以的，你们试的时候多试几次，我也不知道内部机制，就比如说我提交了好久，但是还是搜索不到，有的人说是网站没建成，我觉得也有可能吧。 文章写好了需要提交链接也有介绍，这边想讲一下一个主动提交的方法，不需要自己写代码，没有代码功底或者不想写代码的可以参考下：如果有火狐浏览器的的话下载一个 HttpRequester 插件，其它的http请求测插件应该也可以，我没试，但是原理应该差不多，然后把百度链接提交的主动推送接口调用地址填到URL里面，参数那个调用地址已经补全了，请求方式为POST，然后在Content里填上自己提交的链接，点击Submit就提交成功了。流程如下图所示。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>yilia</tag>
        <tag>畅言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建独立博客]]></title>
    <url>%2F2017%2F07%2F31%2Fhexo-and-github-blog%2F</url>
    <content type="text"><![CDATA[一直以来就想搞个属于自己的博客，但是自己写需要花时间花心思，还得搞个域名和服务器，写在论坛上面又没特色，就一直没有实施，最近看到Hexo+GitHub建立静态博客不仅不需要域名，而且可以设置各种好看的样式，更换起来也很方便，也不需要有代码的基础，瞬间就心动了。花了点功夫，参考了别人的最后还是弄出来，遇到的问题有版本原因，也有个人原因，在这里写个总结，自己下次可以参考，别人也可以参考。可能没耐心的人看起来很繁琐，就不想弄了，但是相信我，你只要试试，非常的简单。 正文 我个人是win10的操作系统，安装的是Hexo3的版本 软件准备 Node.js：创建博客框架。 Git客户端：上传Hexo到GitHub 软件安装 ——Node.js安装—— 点击上面的内容进入Node官网的下载页面，下拉选择下载的版本，根据我的英语水平认为，左边的是当前的稳定版，右边的是最新版，我喜欢新事物，所以我下载的是右边的版本 下载完成后双击打开，直接安装，一直点击下一步，需要修改目录就修改一下，其它内容没有必要修改，最后安装完成。 ——Git安装—— 同样点击进入下载页面，选择Windows版本的点击就可以下载，默认是64位的，有其他选择可以在点击跳转页面进行选择 安装过程也是一直下一步，在安装第三步的时候选择第二个选项如下图 继续装结束，在右击菜单的选项中就会多出两个选项如下，Git GUI Here进入视图界面，Git Base Here 进入命令行界面，本程序用的是命令行界面 这样一来两个软件都安装完成了，接下来可以安装Hexo了。 安装Hexo Hexo常用的有四个命令，在安装完成后有一篇默认的博客里就有介绍，命令如下： 12345hexo generate //可用hexo g,用于生成静态文件hexo server //可用hexo s,用于启动服务器，主要用来本地预览hexo deploy //可用hexo d,用于将本地文件发布到github上hexo new //可用hexo n,用于新建一篇文章hexo clean //用于清理本地已生成的静态文件，没有缩写 在任意位置右键选择Git Base Here进入命令行界面，输入安装指令： 1npm install -g hexo 安装完成后在你常用的文件夹下面新建文件夹Hexo(如：E:\Hexo)，进入该文件夹，右键打开Git命令行界面，输入Hexo初始化的命令如下，Hexo就会在该文件夹建立网站所需要的文件： 1hexo init 继续执行指令安装依赖包： 1npm install 然后使用hexo命令先生成静态文件，然后启动服务器，命令行就会提示可以访问http://localhost:4000进行查看，这就是Hexo3的默认主题landscape，看起来就很高级，只用几个命令就有这样的效果，我当时也是很激动的。当然，这只是本地服务器，要让别人可以访问在接下来会进行介绍。 部署GitHub GitHub账号很好申请，有的话就不用申请了，没有的话到GitHub官网申请一下，也没有什么难度，具体就不介绍了。申请完后进入个人中心界面如下图 点击Repositories进入仓库，然后点击new新建一个仓库显示如下 这边也有一个需要注意的地方就是仓库的名称最好是：GitHub的用户名.github.io，因为这样你默认的访问路径就不带后缀，比如我的用户名是 dorashock，仓库名称就是 doraShock.github.io，访问路径就是 https://dorashock.github.io/，如果用其它名字比如我用 blogBackup 来命名的话，访问路径就是 dorashock.github.io/blogBackup/，这样你部署上去的项目就会没有样式，因为静态页面默认样式在根路径，当然不是说不可以这样弄，我也是后面才知道，可以在配置里面进行设置的，这个下面会说到。 仓库建立后接下来就要部署项目了，首先打开Hexo目录下的配置文件_config.yml，最好使用文本编辑器，在文件末尾加上如下配置 1234deploy: type: gitrepo: github: git@github.com:doraShock/doraShock.github.io,master 第一个doraShock是我GitHub的用户名，第二个是我仓库的地址，这边注意一点就是配置文件里的”:”后面一定要跟一个空格，主题配置也是一样的，当初头像没加空格就搞了我半天。配置完成后保存，如果是第一次使用，或者使用GitHub没用ssh连接的需要配置秘钥，在Git Bash输入如下命令检查是否配置过： 1ls -al ~/.ssh 如果没有文件就说明第一次配置，如果有的话打开C盘，用户文件夹下面，你的用户名里面.ssh文件夹，删除该文件夹下所有文件即可，然后输入下面指令，中间需要输入的情况直接回车，要回车三次，邮箱就是GitHub注册的邮箱： 1ssh-keygen -t rsa -C &quot;872149493@qq.com&quot; 继续输入下面指令： 1ssh-agent -s 继续输入指令: 1ssh-add ~/.ssh/id_rsa 这里会报一个错如下，如果没错就跳过，如果有错误的话输入下面的指令： 12eval `ssh-agent -s`ssh-add 这样你的ssh key就生成了，可以打开.ssh文件夹下面的id_rsa.pub文件复制，也可以在命令行输入下面命令进行复制： 1clip &lt; ~/.ssh/id_rsa.pub 接着打开你的GitHub主页，点击右上角的头像，选择 setting，然后选择 SSH and GPD keys如下图 点击 SSH keys 右边的New SSH key添加你的key，标题随便写 添加后需要验证密码，输入密码后就会发送邮件告诉你已经添加了，这时候回到命令行输入命令进行测试： 1ssh -T git@github.com 我这里有个警告，没有就算了，有的话直接输入yes 这样ssh就配置好了，输入 hexo g 生成静态文件，然后输入hexo d 部署你的项目到GitHub上面去，如果命令报错 Deployer not found: git ，就输入下面的命令安装hexo-deployer-git模块： 1npm install hexo-deployer-git --save 继续执行部署的命令，完成后就可以访问自己的域名进行查看了，我的是https://dorashock.github.io/，默认主题样式如下 这里如果是第一次使用Git的话会执行报错，报错原因也很好理解，就是没有输入GitHub的用户名和邮箱而已，执行下面的命令就可以了： 12git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; 然后就可以看到自己博客了，是不是很简单，默认的样式都让人觉得很有成就感。 写一篇博客 博客搭建好了之后就可以写自己的博客了： 1. 新建博客 还是在hexo文件夹下打开命令行界面，输入命令： 1hexo new &quot;new blog&quot; 2. 编写博客 打开Hexo下面的source_posts路径，就会看到生成的new-blog.md文件了，打开就可以写自己的博客了，写完还是编译上传就可以在自己的博客页面看到了；这里的文章使用的是Markdown语法，博主还在熟悉中，推荐用MarkdownPad2工具进行编辑，会方便很多，语法也不是很难，熟悉下就可以写了，默认的文章内容做一下介绍： 1234567title: new blog //标题，可以用中文date: 2017-07-31 16:04:09 //日期，默认生成，不需要进行更改categories: blog //文章分类，在不同主题效果不同，可以进行控制，可用中文tags: 文章 //文章标签，可用中文，多个标签用 [Java,spring]---#这里是正文，用markdown写&lt;!--more--&gt; //之前的内容会显示在首页，之后的内容会隐藏，当游客点击打开才能看到。 结尾 这样就可以写下自己的经验了，给别人参考也好，自己查阅方便也罢，最主要可以用来装B，哈哈，开个玩笑；在这里非常感谢嘟嘟大神，我是看着他的博客搭建起来的，其中还有添加搜索，国内上传到coding访问更快更方便，主题优化，还有百度认证，访问统计等功能，附上链接 http://tengj.top/categories/hexo干货系列/，我写的跟他差不多，就是补充了点地方，还有就是版本的不同地方，其它的我就不重新写了，看了可以参考他的，写的非常详细，还有我第一篇文章提到的电子书就是找他的，他博客有写，有兴趣可以联系他，我下章把搞得Yilia主题说下就不重复了。第一篇技术文，如有不足，多多指教。 附录 在网上找到MarkdownPad2.5 注册码，记录一下： 12邮箱：Soar360@live.com授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 作者：xwch 链接：http://www.jianshu.com/p/9e5cd946696d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客]]></title>
    <url>%2F2017%2F07%2F27%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[琢磨了好久，终于把博客弄出来了，过程中学了不少东西，毕竟还只是个菜鸟，可以学的东西很多；本来打算的是第一章把使用hexo搭建博客的步骤以及遇到的问题写一下，但是弄好之后莫名奇妙的想把之前的生活做个总结；或许觉得搭起属于自己的博客之后，就是一个新的人生吧…… 正文 时间走得很快，转眼间就两年了。两年的时间在这个行业算是有个起点了，遇到的人也不多，见识的人也不算少，和同资历的人进行比较，比之强则幸，比之弱则叹，庆幸自己的性格，在比强的时候并不气馁，在比弱的时候也不骄傲，三人行必有师，学习别人的长处；不慌不忙，走着自己的路，规划自己的人生。 由于种种原因本人大学匆忙选择了软件工程专业，在我的认知当中编程就是记忆并编写长篇自己不熟悉的语言，这肯定不是我这种连背书都不会的人生存的方式，更不用提自己高中基本刚过及格线的英语水平了，于是在开学之初就肯定的说，毕业后绝对不会去做程序员的。其实也不是因为兴趣，大学的生活被我玩了过去，从来没有什么知识点进入我的脑海，就这样混到大三，在各种渠道到中嗅到了程序员高薪的气息，最终让我踏入程序员的行列。 当时选择Java是因为入门快，有次Java的实验周程序是我自己瞎搞的，给自己的思维注入了点东西，入门也不是很费劲了。后来正式的工作是在扬州，因为在那上的大学，想先积累点经验再去大城市闯荡，也没太强求工资，能学到东西就好。我觉得我还是受到上天的眷顾的，工作学习的过程顺理成章，同时因为有点小机灵，所以基础打的很快，上手的也很快。第一家公司压力很大，或许我见识的少，但是也给我的心理做了一个铺垫，估么着以后遇到什么样的公司都不会有问题了，于是也就安安心心的在里面工作，安安心心的在半年以后独立开发项目，安安心心的手里带新人，不怎么安心的离了职；离职的问题后面说，先总览。 2017年三月来到了上海，进行茫茫的简历投递，学习了简历的写法，也面试了几个公司，报的两年经验还是不好找，最终找到了一家感觉不错的公司，工资也不算很高，但是比之前翻一番了，也足够生活，而且在找工作过程中知道了自己见识的不足之处，觉得再蛰伏一年努力学习，争取补上大学时候浪费的青春。到了新的公司，环境还是很满意的，工作内容简单，比上一个公司好了很多，朝九晚六，慢慢的我也有点懈怠，主要公司技术足够，我想等着别人来教我；事实证明人是不可以懒惰的，在和上个公司轻松很多的环境下，我可以学习的时间更多，还是把人生交给自己吧，依靠别人的想法就不对。 在网上浏览，没事的时候没目的的瞎看，有天在找spring boot的时候看到了hexo的搭建方法，博主还有一个图书推荐的文章，唤起了我的血气，给了二十块钱博主的辛苦费就拿到了几百本电子书，同时按照博主文章搭起自己的博客，开始自己的学习记录之旅，博客搭建过程也是遇到了点问题，在下一章会进行记录，然后把之前的内容做个总结，接着就啃自己的干货吧，因为没有系统性，所以打算从零看起，知道的当做巩固，不知道的正好学习。 总结 我很早以前就喜欢写东西，初中的时候刚看的网络小说也想自己写，高中的时候为了迎合高考全部都是以议论文为主，说实话，我并不是很明白议论文的亮点，我也尝试着去迎合，但不是很理想。 我觉得一篇文章，只有精彩的故事才能吸引读者，包括儿时的想想作文，后来的网络小说；这里我还是有点感谢高三的语文老师，他教会了我这叫记叙文，并且没有像别的老师那样主张议论文，同时开放了我的思维，于是我就是以写记叙文为主，虽然文笔一般，但是我有活跃的思想，有好多次的作文都会被老师点名，说我想法很好，哈哈。 印象里最深的就是高二的时候看完斗罗大陆，月考的时候作文名字叫《禁区》，我因为小说的影响，天马行空般的把盘古写成一个力气很大的孩子，以他父亲的视角，描述了森林深处一个贫瘠的小村因为传说的影响不敢踏出外层模糊光罩的背景，将死之人方可从桥上踏出，他临终时候出来看到外面物产的丰富，以小儿子盘古的懵懂和对父亲的不舍追出打破光罩结束，从而拿到了六十五分的高分，满分是七十分。 这样的分数有人可能觉得没什么，我这有告诉你吧，江苏考生作文七十分，普通人四十到五十分，五十五分就算高分；我也因此语文成绩破了两位数，就这也不到一百三十分，因为我语文也很烂。后来就没有那样的情况了，但是我对自己的写作能力还是比较自信的，虽然分数不高，但是内容足够吸引住别人，可惜到了大学什么都抛弃了，更气的是我们学校补考不要钱，这不是逼我补考吗；现在没事写写，以后说不定有钱拿。 上一家公司的事情说下，我觉得我不说兢兢业业，但是也帮助公司渡过很多难关，而且在旧环境中学习新知识都会拿出来共享的，但是最后公司让我这样收场，谢谢你给我学习的机会，丰富了我的人生经历。具体的内容不谈了，人总要向前看，我没错，我不后悔，再给我一次机会，我只会做的让你更难看，而不是改变我的选择。 感悟 每个人都可以有个丰富的人生，成功的人生用精彩来形容，失败的人生用残酷来形容，精彩内容里也有着很多的残酷，残酷的外表下也包含了精彩，但是人生只看结果，成功的是一颗坚硬的心，一个努力向前的人。 我不是一个有远大抱负的人，但是我有自己的目标，有自己的规划，我有前进的方向，再给自己一把动力，不踏人生巅峰，只为无悔的青春。 新的人生开始…… 2017年7月27日]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
